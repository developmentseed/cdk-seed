import json
import os
from decimal import Decimal
from typing import List
from .types import (
    ExecutionDetails,
    FailedStepDetails,
    CloudwatchEvent,
    SqsMessage,
    StepFunctionInput,
    StepFunctionHistoryEvent,
)
from .services import step_functions_client as sfn, dynamodb_resource as ddb


def get_steps_details(execution_arn: str) -> List[StepFunctionHistoryEvent]:

    response = sfn().get_execution_history(executionArn=execution_arn)
    execution_history: List[StepFunctionHistoryEvent] = response["events"]
    while "nextToken" in response:
        response = sfn().get_execution_history(executionArn=execution_arn)
        execution_history.extend(response["events"])

    return [{"execution_arn": execution_arn, **i} for i in execution_history]  # type: ignore


def generate_table_records(sqs_message: SqsMessage):
    """
    Handler to process an SQS message generated by a StepFunction FAILED or SUCCEEDED
    EventBridge Rule. First the StepFunction execution history is queried and
    appropriate DynamoDB records are generated to store the successfull ingestion or
    the failure.

    """
    msg: CloudwatchEvent = json.loads(sqs_message["body"])
    detail: ExecutionDetails = msg["detail"]

    items = [
        {
            "execution_arn": detail["executionArn"],
            "timestamp": "detail",
            "status": detail["status"],
            "input": json.loads(detail["input"]),
            "output": json.loads(detail["output"]),
            "startDate": detail["startDate"],
            "stopDate": detail["stopDate"],
        }
    ]

    if os.environ.get("EVENT_LOG_LEVEL", "") == "SUMMARY":
        return items

    items.extend(get_steps_details(detail["executionArn"]))  # type: ignore
    return items


def handle_dynamodb(event):
    table = ddb.Table(os.environ["EVENTS_TABLE"])

    with table.batch_writer() as batch:
        for sqs_message in event["Records"]:
            for item in generate_table_records(sqs_message):
                batch.put_item(Item=json.loads(json.dumps(item), parse_float=Decimal))


def handle_postgres(event):
    # TODO - implement
    raise NotImplementedError


def handler(event, context):
    if os.environ["DATASTORE_TYPE"] == "Dynamodb":
        return handle_dynamodb(event)
    if os.environ["DATASTORE_TYPE"] == "Postgres":
        return handle_postgres(event)
