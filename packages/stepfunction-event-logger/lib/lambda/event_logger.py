import json
import os
from decimal import Decimal
from typing import List
from .types import (
    ExecutionDetails,
    FailedStepDetails,
    CloudwatchEvent,
    SqsMessage,
    StepFunctionInput,
    StepFunctionHistoryEvent,
)
from .services import step_functions_client as sfn, dynamodb_resource as ddb


def get_steps_details(execution_arn: str) -> List[StepFunctionHistoryEvent]:

    response = sfn().get_execution_history(executionArn=execution_arn)
    execution_history: List[StepFunctionHistoryEvent] = response["events"]
    while "nextToken" in response:
        response = sfn().get_execution_history(executionArn=execution_arn)
        execution_history.extend(response["events"])

    return [{"execution_arn": execution_arn, **i} for i in execution_history]  # type: ignore


def generate_table_records(sqs_message: SqsMessage):
    """
    Handler to process an SQS message generated by a StepFunction FAILED or SUCCEEDED
    EventBridge Rule. First the StepFunction execution history is queried and
    appropriate DynamoDB records are generated to store the successfull ingestion or
    the failure.

    """
    msg: CloudwatchEvent = json.loads(sqs_message["body"])
    detail: ExecutionDetails = msg["detail"]

    items = [
        {
            "execution_arn": detail["executionArn"],
            "timestamp": "detail",
            "status": detail["status"],
            "input": json.loads(detail["input"]),
            "output": json.loads(detail["output"]),
            "startDate": detail["startDate"],
            "stopDate": detail["stopDate"],
        }
    ]

    if os.environ.get("EVENT_LOG_LEVEL", "") == "SUMMARY":
        return items

    items.extend(get_steps_details(detail["executionArn"]))
    return items

    # sfn_input: StepFunctionInput = json.loads(detail["input"])

    # items = [
    #     {
    #         "partition_key": sfn_input["key"].split("/")[-1],  # manifest filename
    #         "sort_key": sfn_input.get("bundle", {}).get("item_id", "NO_STAC_ITEM_ID"),
    #         "sfn_exec_name": msg["detail"]["name"],
    #         "sfn_name": msg["detail"]["stateMachineArn"].split(":")[-1],
    #         "sfn_exec_start_ts": msg["detail"]["startDate"],
    #         "event_id": msg["id"],
    #         "status": msg["detail"]["status"],
    #         "record_type": "SNAPSHOT",
    #     },
    #     {
    #         "partition_key": sfn_input["key"].split("/")[-1],  # manifest filename
    #         # step_function execution id
    #         "sort_key": f"execution:{msg['detail']['name']}",
    #         "stac_item_id": sfn_input.get("bundle", {}).get(
    #             "item_id", "NO_STAC_ITEM_ID"
    #         ),
    #         "sfn_name": msg["detail"]["stateMachineArn"].split(":")[-1],
    #         "sfn_exec_start_ts": msg["detail"]["startDate"],
    #         "event_id": msg["id"],
    #         "status": msg["detail"]["status"],
    #         "record_type": "EXECUTION_HISTORY",
    #     },
    # ]

    # for item in items:
    #     if msg["detail"]["status"] == "FAILED":

    #         item.update(
    #             get_failure_step_details(execution_arn=msg["detail"]["executionArn"])
    #         )

    #         # execution sepecific item, pre-pend "_" to the failed_step_name, in order
    #         # to exclude that record from showing up in the failures Index
    #         if "stac_item_id" in item.keys():
    #             item["_failed_step_name"] = item["failed_step_name"]
    #             del item["failed_step_name"]

    return items


def handle_dynamodb(event):
    table = ddb.Table(os.environ["EVENTS_TABLE"])

    with table.batch_writer() as batch:
        for sqs_message in event["Records"]:
            for item in generate_table_records(sqs_message):
                batch.put_item(Item=json.loads(json.dumps(item), parse_float=Decimal))


def handle_postgres(event):
    # TODO - implement
    raise NotImplementedError


def handler(event, context):
    if os.environ["DATASTORE_TYPE"] == "Dynamodb":
        return handle_dynamodb(event)
    if os.environ["DATASTORE_TYPE"] == "Postgres":
        return handle_postgres(event)
